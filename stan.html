<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8">
<title>Stan interactive diagnostics</title>

<script src="crossfilter.v1.min.js"></script>
<script src="d3.v3.min.js"></script>
<script src='angular.min.js'></script>

<style>

body {
  font-family: "Helvetica Neue";
  margin: 40px auto;
  width: 960px;
  min-height: 1000px;
}
#body {
  position: relative;
}
footer {
  position: relative;
  top: 15px;
  padding: 2em 0 1em 0;
  font-size: 12px;
}
div#thetaline {
    position: relative;
    top: 30px;
}
h1 {
  font-size: 96px;
  margin-top: .3em;
  margin-bottom: 0;
}
h1 + h2 {
  margin-top: 0;
}
h2 {
  font-weight: 400;
  font-size: 28px;
}
#body > p {
  line-height: 1.5em;
  width: 640px;
  text-rendering: optimizeLegibility;
}
#charts {
  padding: 10px 0;
}
.chart {
  display: inline-block;
  height: 151px;
  margin-bottom: 20px;
}
.reset {
  padding-left: 1em;
  font-size: smaller;
  color: #ccc;
}
.background.bar {
  fill: #ccc;
}
.foreground.bar {
  fill: #570814;
}
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.axis text {
  font: 10px sans-serif;
}
.brush rect.extent {
  fill: #570814;
  fill-opacity: .125;
}
.brush .resize path {
  fill: #eee;
  stroke: #666;
}
#theta-chart {
  width: 420px;
}
#lp-chart {
  width: 420px;
}
aside {
  position: absolute;
  left: 740px;
  font-size: smaller;
  width: 220px;
}
path.chain {
	stroke: #b31028;
	stroke-width: 1;
	fill: none;
}
</style>

</head>




<body>

<div id="body">

<a href="http://mc-stan.org"><img src="stan_logo.png" width="120"></a>

<h1>Stan interactive</h1>

<h2>Interactive diagnostic plots for Hamiltonian Monte Carlo chains</h2>

<p><strong><a href="http://mc-stan.org">Stan</a></strong> is a C++ library for probabilistic sampling, with many interfaces allowing applied researchers to fit complex Bayesian models to their data from inside their favourite analysis software. It is essential to check that the samples have behaved as expected: that they have converged to a posterior distribution, that autocorrelation is not distorting the distribution of values, and that there are no outlier samples biasing the statistics. This is usually done with a mixture of diagnostic statistics and plots, which can be quite time-consuming when there are many parameters, which is why we wrote <strong>stan interactive</strong>. By writing the chains of successive samples into an interactive web page, we can employ the powerful JavaScript libraries D3, crossfilter and angular to recalculate and draw charts on the fly, freeing up the user to concentrate on what the results mean.</p>


<div id="charts">
  <div id="lp-chart" class="chart">
    <div class="title">log-posterior</div>
  </div>
  <div id="theta-chart" class="chart">
    <div class="title">theta</div>
  </div>
</div>

<aside id="totals"><span id="active">-</span> of <span id="total">-</span> samples selected.</aside>


<div id='thetaline'>
</div>

<footer>
  <span style="float:right;">
    <a href="http://mc-stan.org">Stan</a> was released under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a> by the <a href="http://mc-stan.org/team/">Stan Development Team</a>.<br>
    <a href="http://d3js.org">d3.js</a> was released under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a> by <a href="http://bost.ocks.org/mike/">Mike Bostock</a>.<br>
    <a href="http://square.github.io/crossfilter/">crossfilter.js</a> was released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a> by <a href="http://squareup.com">Square, Inc.</a><br>
    <a href='https://angularjs.org'>angular.js</a> was released under the <a href='https://github.com/angular/angular.js/blob/master/LICENSE'>MIT license</a> by Google.<br>
  </span>

</footer>

</div>

<script>
// (It's CSV, but GitHub Pages only gzip's JSON at the moment.)
d3.csv("statastan.csv", function(error, data) {
  // Various formatters.
  var formatNumber = d3.format(",d"),
      formatChange = d3.format("+,d"),
      formatDate = d3.time.format("%B %d, %Y"),
      formatTime = d3.time.format("%I:%M %p");

  // A little coercion, since the CSV is untyped.
  data.forEach(function(d, i) {
    d.index = i;
    d.lp__ = +d.lp__;
    d.theta = +d.theta;
  });
  // Create the crossfilter for the relevant dimensions and groups.
  var chain = crossfilter(data),
      all = chain.groupAll(),
      lp = chain.dimension(function(d) { return d.lp__; }),
      glp = lp.group(function(d) { return Math.floor(d*10) / 10; }),
      theta = chain.dimension(function(d) { return d.theta; }),
      gtheta = theta.group(function(d) { return Math.floor(d *50) / 50; }),
      ind = chain.dimension(function(d) {return d.index}),
      gind = ind.group(function(d) { return Math.floor(d);});
  var charts = [
    barChart()
        .dimension(lp)
        .group(glp)
      .x(d3.scale.linear()
        .domain([-14, -5])
        .rangeRound([0, 10 * 40])),
    barChart()
        .dimension(theta)
        .group(gtheta)
      .x(d3.scale.linear()
        .domain([0, 1])
        .rangeRound([0, 10 * 40]))
  ];
  // Given our array of charts, which we assume are in the same order as the
  // .chart elements in the DOM, bind the charts to the DOM and render them.
  // We also listen to the chart's brush events to update the display.
  var chart = d3.selectAll(".chart")
      .data(charts)
      .each(function(chart) { chart.on("brush", renderAll).on("brushend", renderAll); });
  // Render the total.
  d3.selectAll("#total")
      .text(formatNumber(chain.size()));
  renderAll();
  // Renders the specified chart or list.
  function render(method) {
    d3.select(this).call(method);
  }
  // Whenever the brush moves, re-rendering everything
  function renderAll() {
    chart.each(render);
    //list.each(render);
    d3.select("#active").text(formatNumber(all.value()));
  }
  window.filter = function(filters) {
    filters.forEach(function(d, i) { charts[i].filter(d); });
    renderAll();
  };
  window.reset = function(i) {
    charts[i].filter(null);
    renderAll();
  };



/* ################################################
   ################# bar charts ###################
   ################################################ */


  function barChart() {
    if (!barChart.id) barChart.id = 0;
    var margin = {top: 10, right: 10, bottom: 20, left: 10},
        x,
        y = d3.scale.linear().range([100, 0]),
        id = barChart.id++,
        axis = d3.svg.axis().orient("bottom"),
        brush = d3.svg.brush(),
        brushDirty,
        dimension,
        group,
        round;
    function chart(div) {
      var width = x.range()[1],
          height = y.range()[0];
      y.domain([0, group.top(1)[0].value]);
      div.each(function() {
        var div = d3.select(this),
            g = div.select("g");
        // Create the skeletal chart.
        if (g.empty()) {
          div.select(".title").append("a")
              .attr("href", "javascript:reset(" + id + ")")
              .attr("class", "reset")
              .text("reset")
              .style("display", "none");
          g = div.append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
          g.append("clipPath")
              .attr("id", "clip-" + id)
            .append("rect")
              .attr("width", width)
              .attr("height", height);
          g.selectAll(".bar")
              .data(["background", "foreground"])
            .enter().append("path")
              .attr("class", function(d) { return d + " bar"; })
              .datum(group.all());
          g.selectAll(".foreground.bar")
              .attr("clip-path", "url(#clip-" + id + ")");
          g.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(0," + height + ")")
              .call(axis);
          // Initialize the brush component with pretty resize handles.
          var gBrush = g.append("g").attr("class", "brush").call(brush);
          gBrush.selectAll("rect").attr("height", height);
          gBrush.selectAll(".resize").append("path").attr("d", resizePath);
        }
        // Only redraw the brush if set externally.
        if (brushDirty) {
          brushDirty = false;
          g.selectAll(".brush").call(brush);
          div.select(".title a").style("display", brush.empty() ? "none" : null);
          if (brush.empty()) {
            g.selectAll("#clip-" + id + " rect")
                .attr("x", 0)
                .attr("width", width);
          } else {
            var extent = brush.extent();
            g.selectAll("#clip-" + id + " rect")
                .attr("x", x(extent[0]))
                .attr("width", x(extent[1]) - x(extent[0]));
          }
        }
        g.selectAll(".bar").attr("d", barPath);
      });
      function barPath(groups) {
        var path = [],
            i = -1,
            n = groups.length,
            d;
        while (++i < n) {
          d = groups[i];
          path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
        }
        return path.join("");
      }
      function resizePath(d) {
        var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
        return "M" + (.5 * x) + "," + y
            + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
            + "V" + (2 * y - 6)
            + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
            + "Z"
            + "M" + (2.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8)
            + "M" + (4.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8);
      }
    }
    brush.on("brushstart.chart", function() {
      var div = d3.select(this.parentNode.parentNode.parentNode);
      div.select(".title a").style("display", null);
    });
    brush.on("brush.chart", function() {
      var g = d3.select(this.parentNode),
          extent = brush.extent();
      if (round) g.select(".brush")
          .call(brush.extent(extent = extent.map(round)))
        .selectAll(".resize")
          .style("display", null);
      g.select("#clip-" + id + " rect")
          .attr("x", x(extent[0]))
          .attr("width", x(extent[1]) - x(extent[0]));
      dimension.filterRange(extent);
    });
    brush.on("brushend.chart", function() {
      if (brush.empty()) {
        var div = d3.select(this.parentNode.parentNode.parentNode);
        div.select(".title a").style("display", "none");
        div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
        dimension.filterAll();
      }
    });
    chart.margin = function(_) {
      if (!arguments.length) return margin;
      margin = _;
      return chart;
    };
    chart.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      axis.scale(x);
      brush.x(x);
      return chart;
    };
    chart.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return chart;
    };
    chart.dimension = function(_) {
      if (!arguments.length) return dimension;
      dimension = _;
      return chart;
    };
    chart.filter = function(_) {
      if (_) {
        brush.extent(_);
        dimension.filterRange(_);
      } else {
        brush.clear();
        dimension.filterAll();
      }
      brushDirty = true;
      return chart;
    };
    chart.group = function(_) {
      if (!arguments.length) return group;
      group = _;
      return chart;
    };
    chart.round = function(_) {
      if (!arguments.length) return round;
      round = _;
      return chart;
    };
    return d3.rebind(chart, brush, "on");
  }




/* #################################################
   ################# line charts ###################
   ################################################# */

	var chainwidth = 900,
		chainheight = 300,
		axisLabelSpace = 50,
		legendSpace = 100,
    chainaxispad = 30,
		x = d3.scale.linear().range([0, chainwidth-chainaxispad]),
		y = d3.scale.linear().range([chainheight-chainaxispad, 0]),
		xAxis = d3.svg.axis().scale(x).orient('bottom').ticks(5),
		yAxis = d3.svg.axis().scale(y).orient('left').ticks(5);

	var domainPadding = 0.2;

  var lineminx = d3.min(data, function(d) { return d.index; });
  var linemaxx = d3.max(data, function(d) { return d.index; });
  var lineminy = d3.min(data, function(d) { return d.theta; });
  var linemaxy = d3.max(data, function(d) { return d.theta; });
	x.domain([lineminx,linemaxx]);
	y.domain([lineminy,linemaxy]);

	var makeline = d3.svg.line()
		.x(function(d) { return x(d.index); })
		.y(function(d) { return y(d.theta); });

 var thetasvg = d3.select('div#thetaline').append('svg')
          .attr('width', chainwidth)
 			    .attr('height', chainheight)
		.append('g')
          .attr('width', chainwidth-chainaxispad)
          .attr('height',chainheight-chainaxispad)
          .attr('transform', 'translate(' + chainaxispad + ',0)');

	var linedataNest = d3.nest()
		.key(function(d) {return d.twoway;})
		.entries(data);

	linedataNest.forEach(function(d,i) {
    thetasvg.append('path')
  		.attr('class', 'chain')
  		.attr('d', makeline(d.values));
  });

  var xaxisheight = chainheight-chainaxispad;

	thetasvg.append('g')
		.attr('class', 'x axis')
		.attr('transform', 'translate(0,' + xaxisheight + ')')
		.call(xAxis);

	thetasvg.append('g')
		.attr('class', 'y axis')
		.call(yAxis);


});
</script>


</body>
</html>
