<!DOCTYPE html>

<!--
    stan interactive was created by Robert Grant
    With code inspired by:
    https://github.com/square/crossfilter/tree/gh-pages
    https://gist.github.com/tyrauber/3350666
-->

<meta charset="utf-8">
<title>Stan interactive diagnostics</title>
<style>

body {
  font-family: "Helvetica Neue";
  margin: 40px auto;
  width: 960px;
  min-height: 2000px;
}
#body {
  position: relative;
}
footer {
  padding: 2em 0 1em 0;
  font-size: 12px;
}
h1 {
  font-size: 96px;
  margin-top: .3em;
  margin-bottom: 0;
}
h1 + h2 {
  margin-top: 0;
}
h2 {
  font-weight: 400;
  font-size: 28px;
}
#body > p {
  line-height: 1.5em;
  width: 640px;
  text-rendering: optimizeLegibility;
}
#charts {
  padding: 10px 0;
}
.chart {
  display: inline-block;
  height: 151px;
  margin-bottom: 20px;
}
.reset {
  padding-left: 1em;
  font-size: smaller;
  color: #ccc;
}
.background.bar {
  fill: #ccc;
}
.foreground.bar {
  fill: #4682b4;
}
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
.axis text {
  font: 10px sans-serif;
}
.brush rect.extent {
  fill: steelblue;
  fill-opacity: .125;
}
.brush .resize path {
  fill: #eee;
  stroke: #666;
}
#theta-chart {
  width: 420px;
}
#lp-chart {
  width: 420px;
}
#flight-list {
  min-height: 1024px;
}
#flight-list .date,
#flight-list .day {
  margin-bottom: .4em;
}
#flight-list .flight {
  line-height: 1.5em;
  background: #eee;
  width: 640px;
  margin-bottom: 1px;
}
#flight-list .time {
  color: #999;
}
#flight-list .flight div {
  display: inline-block;
  width: 100px;
}
#flight-list div.distance,
#flight-list div.delay {
  width: 160px;
  padding-right: 10px;
  text-align: right;
}
#flight-list .early {
  color: green;
}
aside {
  position: absolute;
  left: 740px;
  font-size: smaller;
  width: 220px;
}
</style>

<div id="body">

<a href="http://mc-stan.org"><img src="stan_logo.png" width="120"></a>

<h1>Stan interactive</h1>

<h2>Interactive diagnostic plots for Hamiltonian Monte Carlo chains</h2>

<p><strong><a href="http://mc-stan.org">Stan</a></strong> is a C++ library for probabilistic sampling, with many interfaces allowing applied researchers to fit complex Bayesian models to their data from inside their favourite analysis software. It is essential to check that the samples have behaved as expected: that they have converged to a posterior distribution, that autocorrelation is not distorting the distribution of values, and that there are no outlier samples biasing the statistics. This is usually done with a mixture of diagnostic statistics and plots, which can be quite time-consuming when there are many parameters, which is why we wrote <strong>stan interactive</strong>. By writing the chains of successive samples into an interactive web page, we can employ the powerful JavaScript libraries D3 and crossfilter.</p>


<div id="charts">
  <div id="lp-chart" class="chart">
    <div class="title">log-posterior</div>
  </div>
  <div id="theta-chart" class="chart">
    <div class="title">theta</div>
  </div>
</div>

<aside id="totals"><span id="active">-</span> of <span id="total">-</span> samples selected.</aside>

<div id="lists">
  <div id="flight-list" class="list"></div>
</div>

<footer>
  <span style="float:right;">
    <a href="http://mc-stan.org">Stan</a> was released under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a> by the <a href="http://mc-stan.org/team/">Stan Development Team</a>.<br>
    <a href="http://d3js.org">d3.js</a> was released under the <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a> by <a href="http://bost.ocks.org/mike/">Mike Bostock</a>.<br>
    <a href="http://square.github.io/crossfilter/">crossfilter.js</a> was released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a> by <a href="http://squareup.com">Square, Inc.</a><br>
  </span>

</footer>

</div>

<script src="crossfilter.v1.min.js"></script>
<script src="d3.v3.min.js"></script>
<script>
// (It's CSV, but GitHub Pages only gzip's JSON at the moment.)
d3.csv("statastan.csv", function(error, data) {
  // Various formatters.
  var formatNumber = d3.format(",d"),
      formatChange = d3.format("+,d"),
      formatDate = d3.time.format("%B %d, %Y"),
      formatTime = d3.time.format("%I:%M %p");
  // A nest operator, for grouping the flight list.
  /*
    var nestByDate = d3.nest()
      .key(function(d) { return d3.time.day(d.date); });
  */
  // A little coercion, since the CSV is untyped.
  data.forEach(function(d, i) {
    d.index = i;
    d.lp__ = +d.lp__;
    d.theta = +d.theta;
  });
  // Create the crossfilter for the relevant dimensions and groups.
  var chain = crossfilter(data),
      all = chain.groupAll(),
      lp = chain.dimension(function(d) { return d.lp__; }),
      glp = lp.group(function(d) { return Math.floor(d*10) / 10; }),
      theta = chain.dimension(function(d) { return d.theta; }),
      gtheta = theta.group(function(d) { return Math.floor(d *50) / 50; }),
      ind = chain.dimension(function(d) {return d.index}),
      gind = ind.group(function(d) { return Math.floor(d);});
  var charts = [
    lineChart()
        .dimension(lp)
        .group(glp)
      .x(d3.scale.linear()
        .domain([-14, -5])
        .rangeRound([0, 10 * 40])),
    barChart()
        .dimension(theta)
        .group(gtheta)
      .x(d3.scale.linear()
        .domain([0, 1])
        .rangeRound([0, 10 * 40]))
  ];
  // Given our array of charts, which we assume are in the same order as the
  // .chart elements in the DOM, bind the charts to the DOM and render them.
  // We also listen to the chart's brush events to update the display.
  var chart = d3.selectAll(".chart")
      .data(charts)
      .each(function(chart) { chart.on("brush", renderAll).on("brushend", renderAll); });
  // Render the initial lists.
/*
    var list = d3.selectAll(".list")
      .data([chainList]);
*/
  // Render the total.
  d3.selectAll("#total")
      .text(formatNumber(chain.size()));
  renderAll();
  // Renders the specified chart or list.
  function render(method) {
    d3.select(this).call(method);
  }
  // Whenever the brush moves, re-rendering everything
  function renderAll() {
    chart.each(render);
    //list.each(render);
    d3.select("#active").text(formatNumber(all.value()));
  }
  /*
  // Like d3.time.format, but faster.
  function parseDate(d) {
    return new Date(2001,
        d.substring(0, 2) - 1,
        d.substring(2, 4),
        d.substring(4, 6),
        d.substring(6, 8));
  }
  */
  window.filter = function(filters) {
    filters.forEach(function(d, i) { charts[i].filter(d); });
    renderAll();
  };
  window.reset = function(i) {
    charts[i].filter(null);
    renderAll();
  };

/*
  function chainList(div) {
    var chainByDate = nestByDate.entries(date.top(40));
    div.each(function() {
      var date = d3.select(this).selectAll(".date")
          .data(flightsByDate, function(d) { return d.key; });
      date.enter().append("div")
          .attr("class", "date")
        .append("div")
          .attr("class", "day")
          .text(function(d) { return formatDate(d.values[0].date); });
      date.exit().remove();
      var flight = date.order().selectAll(".flight")
          .data(function(d) { return d.values; }, function(d) { return d.index; });
      var flightEnter = flight.enter().append("div")
          .attr("class", "flight");
      flightEnter.append("div")
          .attr("class", "time")
          .text(function(d) { return formatTime(d.date); });
      flightEnter.append("div")
          .attr("class", "origin")
          .text(function(d) { return d.origin; });
      flightEnter.append("div")
          .attr("class", "destination")
          .text(function(d) { return d.destination; });
      flightEnter.append("div")
          .attr("class", "distance")
          .text(function(d) { return formatNumber(d.distance) + " mi."; });
      flightEnter.append("div")
          .attr("class", "delay")
          .classed("early", function(d) { return d.delay < 0; })
          .text(function(d) { return formatChange(d.delay) + " min."; });
      flight.exit().remove();
      flight.order();
    });
  }
  */


/* ################################################
   ################# bar charts ###################
   ################################################ */


  function barChart() {
    if (!barChart.id) barChart.id = 0;
    var margin = {top: 10, right: 10, bottom: 20, left: 10},
        x,
        y = d3.scale.linear().range([100, 0]),
        id = barChart.id++,
        axis = d3.svg.axis().orient("bottom"),
        brush = d3.svg.brush(),
        brushDirty,
        dimension,
        group,
        round;
    function chart(div) {
      var width = x.range()[1],
          height = y.range()[0];
      y.domain([0, group.top(1)[0].value]);
      div.each(function() {
        var div = d3.select(this),
            g = div.select("g");
        // Create the skeletal chart.
        if (g.empty()) {
          div.select(".title").append("a")
              .attr("href", "javascript:reset(" + id + ")")
              .attr("class", "reset")
              .text("reset")
              .style("display", "none");
          g = div.append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
          g.append("clipPath")
              .attr("id", "clip-" + id)
            .append("rect")
              .attr("width", width)
              .attr("height", height);
          g.selectAll(".bar")
              .data(["background", "foreground"])
            .enter().append("path")
              .attr("class", function(d) { return d + " bar"; })
              .datum(group.all());
          g.selectAll(".foreground.bar")
              .attr("clip-path", "url(#clip-" + id + ")");
          g.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(0," + height + ")")
              .call(axis);
          // Initialize the brush component with pretty resize handles.
          var gBrush = g.append("g").attr("class", "brush").call(brush);
          gBrush.selectAll("rect").attr("height", height);
          gBrush.selectAll(".resize").append("path").attr("d", resizePath);
        }
        // Only redraw the brush if set externally.
        if (brushDirty) {
          brushDirty = false;
          g.selectAll(".brush").call(brush);
          div.select(".title a").style("display", brush.empty() ? "none" : null);
          if (brush.empty()) {
            g.selectAll("#clip-" + id + " rect")
                .attr("x", 0)
                .attr("width", width);
          } else {
            var extent = brush.extent();
            g.selectAll("#clip-" + id + " rect")
                .attr("x", x(extent[0]))
                .attr("width", x(extent[1]) - x(extent[0]));
          }
        }
        g.selectAll(".bar").attr("d", barPath);
      });
      function barPath(groups) {
        var path = [],
            i = -1,
            n = groups.length,
            d;
        while (++i < n) {
          d = groups[i];
          path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
        }
        return path.join("");
      }
      function resizePath(d) {
        var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
        return "M" + (.5 * x) + "," + y
            + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
            + "V" + (2 * y - 6)
            + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
            + "Z"
            + "M" + (2.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8)
            + "M" + (4.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8);
      }
    }
    brush.on("brushstart.chart", function() {
      var div = d3.select(this.parentNode.parentNode.parentNode);
      div.select(".title a").style("display", null);
    });
    brush.on("brush.chart", function() {
      var g = d3.select(this.parentNode),
          extent = brush.extent();
      if (round) g.select(".brush")
          .call(brush.extent(extent = extent.map(round)))
        .selectAll(".resize")
          .style("display", null);
      g.select("#clip-" + id + " rect")
          .attr("x", x(extent[0]))
          .attr("width", x(extent[1]) - x(extent[0]));
      dimension.filterRange(extent);
    });
    brush.on("brushend.chart", function() {
      if (brush.empty()) {
        var div = d3.select(this.parentNode.parentNode.parentNode);
        div.select(".title a").style("display", "none");
        div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
        dimension.filterAll();
      }
    });
    chart.margin = function(_) {
      if (!arguments.length) return margin;
      margin = _;
      return chart;
    };
    chart.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      axis.scale(x);
      brush.x(x);
      return chart;
    };
    chart.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return chart;
    };
    chart.dimension = function(_) {
      if (!arguments.length) return dimension;
      dimension = _;
      return chart;
    };
    chart.filter = function(_) {
      if (_) {
        brush.extent(_);
        dimension.filterRange(_);
      } else {
        brush.clear();
        dimension.filterAll();
      }
      brushDirty = true;
      return chart;
    };
    chart.group = function(_) {
      if (!arguments.length) return group;
      group = _;
      return chart;
    };
    chart.round = function(_) {
      if (!arguments.length) return round;
      round = _;
      return chart;
    };
    return d3.rebind(chart, brush, "on");
  }


/* #################################################
   ################# line charts ###################
   ################################################# */

  function lineChart() {
    if (!lineChart.id) lineChart.id = 0;

    var margin = {top: 10, right: 10, bottom: 20, left: 10},
        x,
        y = d3.scale.linear().range([100, 0]),
        id = lineChart.id++,
        axis = d3.svg.axis().orient("bottom"),
        brush = d3.svg.brush(),
        brushDirty,
        dimension,
        group,
        round;

    function chart(div) {
      var width = x.range()[1],
          height = y.range()[0];

      y.domain([0, group.top(1)[0].value]);

      div.each(function() {
        var div = d3.select(this),
            g = div.select("g");

        // Create the skeletal chart.
        if (g.empty()) {
          div.select(".title").append("a")
              .attr("href", "javascript:reset(" + id + ")")
              .attr("class", "reset")
              .text("reset")
              .style("display", "none");

          g = div.append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("svg:g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
              .attr('id', 'graphSVG');

          g.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(0," + height + ")")
              .call(axis);

          // Initialize the brush component with pretty resize handles.
          var gBrush = g.append("g").attr("class", "brush").call(brush);
          gBrush.selectAll("rect").attr("height", height);
          gBrush.selectAll(".resize").append("path").attr("d", resizePath);
        }

        // Only redraw the brush if set externally.
        if (brushDirty) {
          brushDirty = false;
          g.selectAll(".brush").call(brush);
          div.select(".title a").style("display", brush.empty() ? "none" : null);
          if (brush.empty()) {
            g.selectAll("#clip-" + id + " rect")
                .attr("x", 0)
                .attr("width", width);
          } else {
            var extent = brush.extent();
            g.selectAll("#clip-" + id + " rect")
                .attr("x", x(extent[0]))
                .attr("width", x(extent[1]) - x(extent[0]));
          }
        }
        g.append("svg:path").datum(group.all()).attr("d",linePath(height,width,group.all())).attr("class", "data3");
      });

      function linePath(h,w,groups){

         var x = d3.time.scale().domain([groups[0].key, groups[groups.length-1].key]).range([0, w]);
          var y = d3.scale.linear().domain([0, d3.max(groups, function(d) { return d.value; })]).range([h, 0]);
          var line = d3.svg.line()
          .x(function(d,i) { return x(d.key); })
          .y(function(d) { return y(d.value); })
          return line;
      }

      function resizePath(d) {
        var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
        return "M" + (.5 * x) + "," + y
            + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
            + "V" + (2 * y - 6)
            + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
            + "Z"
            + "M" + (2.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8)
            + "M" + (4.5 * x) + "," + (y + 8)
            + "V" + (2 * y - 8);
      }
    }

    brush.on("brushstart.chart", function() {
      var div = d3.select(this.parentNode.parentNode.parentNode);
      div.select(".title a").style("display", null);
    });

    brush.on("brush.chart", function() {
      var g = d3.select(this.parentNode),
          extent = brush.extent();
      if (round) g.select(".brush")
          .call(brush.extent(extent = extent.map(round)))
        .selectAll(".resize")
          .style("display", null);
      g.select("#clip-" + id + " rect")
          .attr("x", x(extent[0]))
          .attr("width", x(extent[1]) - x(extent[0]));
      dimension.filterRange(extent);
    });

    brush.on("brushend.chart", function() {
      if (brush.empty()) {
        var div = d3.select(this.parentNode.parentNode.parentNode);
        div.select(".title a").style("display", "none");
        div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
        dimension.filterAll();
      }
    });

    chart.margin = function(_) {
      if (!arguments.length) return margin;
      margin = _;
      return chart;
    };

    chart.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      axis.scale(x);
      brush.x(x);
      return chart;
    };

    chart.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return chart;
    };

    chart.dimension = function(_) {
      if (!arguments.length) return dimension;
      dimension = _;
      return chart;
    };

    chart.filter = function(_) {
      if (_) {
        brush.extent(_);
        dimension.filterRange(_);
      } else {
        brush.clear();
        dimension.filterAll();
      }
      brushDirty = true;
      return chart;
    };

    chart.group = function(_) {
      if (!arguments.length) return group;
      group = _;
      return chart;
    };

    chart.round = function(_) {
      if (!arguments.length) return round;
      round = _;
      return chart;
    };

    return d3.rebind(chart, brush, "on");

  }


});
</script>
